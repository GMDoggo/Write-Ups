# About
You think your Algebra skills are pretty good huh? Well let's test it out.
## Source
```python
from Crypto.Util.number import *
from sage.all import randint

p = getPrime(512)
q = getPrime(512)
N = p * q

e = 0x10001

m = bytes_to_long(b"DawgCTF{fake_flag}")

c = pow(m, e, N)

print("N =", N)
print("e =", e)
print("ct =", c)
print()

a = randint(0, 2**100)
b = randint(0, 2**100)
c = randint(0, 2**100)
d = randint(0, 2**100)

x = a * p + b * q
y = c * p + d * q

print("a =", a)
print("b =", b)
print("c =", c)
print("d =", d)
print()
print("x =", x)
print("y =", y)
```
```txt
N = 82012538447359821165849738352756467719053530066892750177578020351019136006996881441650616631012602654920370573185549134046659875914860421394782338722082599261391182262036434549525388081948429632803770833590739702562845306267418403878169267641023564108136843672261999376998284926318313315387819024961709097101
e = 65537
ct = 16978597269030388872549064541934623430749704732655891928833779185083334396093332647023718343748730349576361193985691953617733288330780060179716905267988202710452028943623598185277149645724247199640730959820455032298145782015884558972868277752456856802145299858618876838286795962548300080924547387662096543717

a = 149738867837230590596162146900
b = 743799113257239690478459408953
c = 351498883480247386367558572595
d = 1175770398223262147164171561358

x = 6836728736678282915469852947219518538837808913380425472016857154639492051766923345186030197640091719641785981050969319578519968972834509899732176840511342124020344870655741074618585883
y = 12203451977234755811396526665700561863946871005728263879373008871704520841041885029745864562375412192520795388389509063064717933869698154304534842876137996238014648925041725231457010083
```


# Solve
We were given an RSA public key alongside random integers a,b,c,d and then:
- `x = a * p + b * q`
- `y = c * p + d * q`
Our goal is to decrypt ct to get the flag — i.e., recover the plaintext `m`.

In normal RSA:
- You can't recover `m` from `ct` unless you know the **private key**, which depends on the prime factors `p` and `q` of `N`.

In this we can solve for p and q
```
x = a * p + b * q
y = c * p + d * q
```
This allows us to do the following:
- Check if `p * q == N` to be sure.
- Compute `φ(N) = (p - 1) * (q - 1)`
- Compute `d = inverse(e, φ(N))`
- Decrypt: `m = pow(ct, d, N)`
- Convert the integer `m` back to bytes → the flag!

```python
from Crypto.Util.number import inverse, long_to_bytes
from fractions import Fraction

# Given values
N = 82012538447359821165849738352756467719053530066892750177578020351019136006996881441650616631012602654920370573185549134046659875914860421394782338722082599261391182262036434549525388081948429632803770833590739702562845306267418403878169267641023564108136843672261999376998284926318313315387819024961709097101
e = 65537
ct = 16978597269030388872549064541934623430749704732655891928833779185083334396093332647023718343748730349576361193985691953617733288330780060179716905267988202710452028943623598185277149645724247199640730959820455032298145782015884558972868277752456856802145299858618876838286795962548300080924547387662096543717

a = 149738867837230590596162146900
b = 743799113257239690478459408953
c = 351498883480247386367558572595
d = 1175770398223262147164171561358

x = 6836728736678282915469852947219518538837808913380425472016857154639492051766923345186030197640091719641785981050969319578519968972834509899732176840511342124020344870655741074618585883
y = 12203451977234755811396526665700561863946871005728263879373008871704520841041885029745864562375412192520795388389509063064717933869698154304534842876137996238014648925041725231457010083

# Compute determinant
det = a * d - b * c

# Compute p and q
p = (x * d - b * y) // det
q = (a * y - x * c) // det

assert p * q == N  # Sanity check

# Compute private exponent
phi = (p - 1) * (q - 1)
d_priv = inverse(e, phi)

# Decrypt
m = pow(ct, d_priv, N)
print(long_to_bytes(m))
```

`DawgCTF{wh0_s41d_m4th_15_us3l3ss?}`

