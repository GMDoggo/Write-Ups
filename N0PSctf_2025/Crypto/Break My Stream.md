# About
CrypTopia is testing their next gen encryption algorithm. We believe that the way they implemented it may have a flaw...

## Source
```
import os

class CrypTopiaSC:

    @staticmethod
    def KSA(key, n):
        S = list(range(n))
        j = 0
        for i in range(n):
            j = ((j + S[i] + key[i % len(key)]) >> 4 | (j - S[i] + key[i % len(key)]) << 4) & (n-1)
            S[i], S[j] = S[j], S[i]
        return S

    @staticmethod
    def PRGA(S, n):
        i = 0
        j = 0
        while True:
            i = (i+1) & (n-1)
            j = (j+S[i]) & (n-1)
            S[i], S[j] = S[j], S[i]
            yield S[((S[i] + S[j]) >> 4 | (S[i] - S[j]) << 4) & (n-1)]

    def __init__(self, key, n=256):
        self.KeyGenerator = self.PRGA(self.KSA(key, n), n)

    def encrypt(self, message):
        return bytes([char ^ next(self.KeyGenerator) for char in message])

def main():
    flag = b"XXX"
    key = os.urandom(256)
    encrypted_flag = CrypTopiaSC(key).encrypt(flag)
    print("Welcome to our first version of CrypTopia Stream Cipher!\nYou can here encrypt any message you want.")
    print(f"Oh, one last thing: {encrypted_flag.hex()}")
    while True:
        pt = input("Enter your message: ").encode()
        ct = CrypTopiaSC(key).encrypt(pt)
        print(ct.hex())

if __name__ == "__main__":
    main() 
```

# Solve

- The cipher uses a fixed 256-byte key (generated by os.urandom(256) in the main function).
- Each time a new CrypTopiaSC instance is created (for the flag or user input), the KSA initializes the state array S using the same key, and the PRGA generates the same keystream for the first 22 bytes.
- This means the keystream used to encrypt the flag (enc_flag = flag XOR keystream) is identical to the keystream used to encrypt a user-provided 22-byte plaintext (enc_input = input XOR keystream).

```
Welcome to our first version of CrypTopia Stream Cipher!
You can here encrypt any message you want.
Oh, one last thing: 7e262f010d1dd5f3f5cad5abdbde1fbfe040600e5522a9
Enter your message: AAAAAAAAAAAAAAAAAAAAAAA
71573e133729a1c780c7cba7abec0acaca3272613a4d95
Enter your message: 
```

We can provide a 22 character string to utilize the keystream reuse.

```
# Encrypted flag and ciphertext
enc_flag_hex = "7e262f010d1dd5f3f5cad5abdbde1fbfe040600e5522a9"
enc_input_hex = "71573e133729a1c780c7cba7abec0acaca3272613a4d95"
enc_flag = bytes.fromhex(enc_flag_hex)
enc_input = bytes.fromhex(enc_input_hex)
our_input = b"A" * 22  # Match the 22-byte ciphertext

# Recover the flag
flag = bytes(a ^ b ^ c for a, b, c in zip(enc_flag, enc_input, our_input))

# Print the flag, handling non-printable characters
flag_str = ""
for b in flag:
    if 32 <= b <= 126:  # Printable ASCII range
        flag_str += chr(b)
    else:
        flag_str += f"[{b:02x}]"  # Non-printable as [hex]

print("Flag:", flag_str)
print("Flag (hex):", flag.hex())
```

```
Flag: N0PS{u5u4L_M1sT4k3S...}
```